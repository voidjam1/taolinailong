<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>ESCAPE: FBX WORLD</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="loading">正在加载 FBX 宏大世界... (请稍候)</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 20, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 强力灯光配置，确保 FBX 贴图能看清
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        scene.add(hemiLight);

      // --- 核心：FBX 加载逻辑 (修复黑屏版) ---
        const fbxLoader = new FBXLoader();
        fbxLoader.load('map.fbx', (object) => {
            // 1. 自动适配大小（防止模型太大或太小）
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3()).length();
            const scale = 50 / size; // 强制缩放到合适尺寸
            object.scale.set(scale, scale, scale);
            
            // 2. 遍历并修复材质
            object.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // 修复全黑的关键：如果模型太黑，强制使用 MeshStandardMaterial
                    if (child.material) {
                        // 允许材质接收光照，如果 FBX 导出时没带贴图，至少能看到颜色
                        child.material.emissive = new THREE.Color(0x222222); // 轻微自发光防止死黑
                        child.material.roughness = 0.8; 
                        child.material.metalness = 0.2;
                    }
                }
            });

            scene.add(object);
            document.getElementById('loading').style.display = 'none';
            console.log("地图加载成功！");
        }, 
        (xhr) => {
            const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
            document.getElementById('loading').innerText = `加载中: ${percent}%`;
        },
        (error) => {
            console.error("加载失败，请检查文件名或路径：", error);
            document.getElementById('loading').innerText = "加载失败，请检查文件";
        });

        // --- 玩家占位符 ---
        const player = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({color: 0x00ff00}));
        player.position.set(0, 1, 0);
        scene.add(player);

        // --- 简易运动逻辑 ---
        const keys = {};
        window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
        window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

        function animate() {
            requestAnimationFrame(animate);
            if(keys['w']) player.position.z -= 0.2;
            if(keys['s']) player.position.z += 0.2;
            if(keys['a']) player.position.x -= 0.2;
            if(keys['d']) player.position.x += 0.2;

            // 相机跟随
            camera.position.set(player.position.x, player.position.y + 10, player.position.z + 20);
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
