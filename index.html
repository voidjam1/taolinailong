<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€ƒç¦» XXX - 3D æé™è·‘é…·</title>
    <style>
        /* ç®€å•çš„ UI æ ·å¼ */
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Arial', sans-serif; user-select: none; }
        
        #ui-container {
            position: absolute; top: 20px; left: 20px; 
            color: white; pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }
        h1 { margin: 0; font-size: 24px; color: #ffeb3b; }
        p { margin: 5px 0; font-size: 16px; }
        .key { display: inline-block; background: rgba(255,255,255,0.3); padding: 2px 6px; border-radius: 4px; }

        /* æ¸¸æˆç»“æŸ/èƒœåˆ© å¼¹çª— */
        #overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: white;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center;
        }
        #overlay h2 { font-size: 48px; margin-bottom: 20px; color: #ff4444; }
        #restart-btn {
            padding: 15px 30px; font-size: 20px; cursor: pointer;
            background: white; border: none; border-radius: 50px;
            font-weight: bold; color: #333; transition: 0.2s;
        }
        #restart-btn:hover { background: #ffeb3b; transform: scale(1.1); }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>ğŸƒ é€ƒç¦» XXX</h1>
        <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> ç§»åŠ¨</p>
        <p><span class="key">SPACE</span> è·³è·ƒ</p>
        <p>âš ï¸ åˆ«å›å¤´ï¼å®ƒå°±åœ¨ä½ èº«åï¼</p>
    </div>

    <div id="overlay">
        <h2 id="status-text">ä½ è¢«æŠ“ä½äº†ï¼ğŸ˜­</h2>
        <button id="restart-btn" onclick="location.reload()">å†è¯•ä¸€æ¬¡</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'; // é¢„ç•™ç»™ä½ åŠ è½½æ¨¡å‹ç”¨

        // ================= é…ç½®åŒºåŸŸ =================
        const CONFIG = {
            playerSpeed: 0.2,       // ç©å®¶è·‘å¾—æœ‰å¤šå¿«
            jumpForce: 0.35,        // è·³è·ƒé«˜åº¦
            gravity: 0.015,         // é‡åŠ›
            chaserSpeed: 0.19,      // æ€ªç‰©è¿½ä½ çš„é€Ÿåº¦ (æ¯”ç©å®¶ç¨æ…¢ä¸€ç‚¹ç‚¹)
            chaserStartDist: 15,    // æ€ªç‰©åˆå§‹è·ç¦»ä½ å¤šè¿œ
        };
        // ===========================================

        // 1. åˆå§‹åŒ–åœºæ™¯
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60); // è¿œå¤„åŠ ç‚¹é›¾ï¼Œå¢åŠ ç¥ç§˜æ„Ÿ

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // å¼€å¯é˜´å½±
        document.body.appendChild(renderer.domElement);

        // 2. ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        // ä¼˜åŒ–é˜´å½±èŒƒå›´
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        scene.add(sunLight);

        // 3. åˆ›å»ºç©å®¶ (Player)
        // ğŸŸ© TODO: å¦‚æœä½ è¦å¯¼å…¥è‡ªå·±çš„æ¨¡å‹ï¼Œè¯·åœ¨è¿™é‡Œä¿®æ”¹
        const playerGeo = new THREE.BoxGeometry(1, 2, 1); // ç®€å•çš„æ–¹å—äºº
        const playerMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); 
        const player = new THREE.Mesh(playerGeo, playerMat);
        player.position.set(0, 1, 0);
        player.castShadow = true;
        scene.add(player);

        // 4. åˆ›å»ºè¿½é€è€… (The Chaser - XXX)
        // ğŸŸ¥ TODO: è¿™é‡Œä¹Ÿå¯ä»¥æ¢æˆææ€–æ¨¡å‹çš„ GLB
        const chaserGeo = new THREE.SphereGeometry(1.5, 32, 32);
        const chaserMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 });
        const chaser = new THREE.Mesh(chaserGeo, chaserMat);
        // æ€ªç‰©åˆå§‹åœ¨ç©å®¶èº«å (Zè½´æ­£å‘æ˜¯èº«å)
        chaser.position.set(0, 2, CONFIG.chaserStartDist); 
        chaser.castShadow = true;
        scene.add(chaser);

        // 5. åœ°å½¢ç”Ÿæˆ (ç®€å•çš„æ— å°½è·‘é“æ•ˆæœ)
        const groundGeo = new THREE.PlaneGeometry(100, 10000);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.z = -4000; // åœ°é¢å‘è¿œå¤„å»¶ä¼¸
        ground.receiveShadow = true;
        scene.add(ground);

        // éšæœºç”Ÿæˆä¸€äº›éšœç¢ç‰©
        const obstacles = [];
        for (let i = 0; i < 100; i++) {
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(3, 3, 3),
                new THREE.MeshStandardMaterial({ color: 0xffa500 })
            );
            // éšæœºåˆ†å¸ƒåœ¨è·‘é“å‰æ–¹
            const x = (Math.random() - 0.5) * 40; 
            const z = - (Math.random() * 500 + 20); // ä» z=-20 åˆ° z=-520
            box.position.set(x, 1.5, z);
            box.castShadow = true;
            box.receiveShadow = true;
            scene.add(box);
            obstacles.push(box);
        }

        // 6. æ§åˆ¶é€»è¾‘
        const keys = { w: false, a: false, s: false, d: false };
        let velocityY = 0;
        let isJumping = false;
        let isGameOver = false;

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (e.code === 'Space' && !isJumping && !isGameOver) {
                velocityY = CONFIG.jumpForce;
                isJumping = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
        });

        // 7. æ¸¸æˆä¸»å¾ªç¯ (æ¯ä¸€å¸§éƒ½åœ¨è·‘)
        function animate() {
            requestAnimationFrame(animate);
            if (isGameOver) return;

            // --- ç©å®¶ç§»åŠ¨ ---
            // Wé”®ï¼šå‘ Zè½´è´Ÿæ–¹å‘è·‘ (å±å¹•æ·±å¤„)
            if (keys.w) player.position.z -= CONFIG.playerSpeed;
            if (keys.s) player.position.z += CONFIG.playerSpeed;
            if (keys.a) player.position.x -= CONFIG.playerSpeed;
            if (keys.d) player.position.x += CONFIG.playerSpeed;

            // --- é‡åŠ›ä¸è·³è·ƒ ---
            player.position.y += velocityY;
            if (player.position.y > 1) { // 1 æ˜¯åœ°é¢é«˜åº¦(ç©å®¶ä¸­å¿ƒç‚¹)
                velocityY -= CONFIG.gravity;
            } else {
                player.position.y = 1;
                velocityY = 0;
                isJumping = false;
            }

            // --- æ‘„åƒæœºè·Ÿéš ---
            // æ‘„åƒæœºåœ¨ç©å®¶èº«åä¸Šæ–¹
            camera.position.x = player.position.x * 0.5; // ç¨å¾®å¸¦ç‚¹å»¶è¿Ÿæ„Ÿ
            camera.position.y = player.position.y + 5;
            camera.position.z = player.position.z + 10; 
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z - 5);

            // --- è¿½é€è€… AI ---
            // ç®€å•çš„è¿½è¸ªç®—æ³•ï¼šä¸æ–­å‘ç©å®¶ä½ç½®é æ‹¢
            const targetPos = player.position.clone();
            const direction = new THREE.Vector3().subVectors(targetPos, chaser.position).normalize();
            
            // å¦‚æœä½ æŒ‰Wè·‘ï¼Œæ€ªç‰©å°±è¿½å¾—å¿«ï¼›å¦‚æœä½ ä¸åŠ¨ï¼Œæ€ªç‰©å°±æ…¢æ…¢é£˜è¿‡æ¥
            chaser.position.add(direction.multiplyScalar(CONFIG.chaserSpeed));
            // ä¿æŒæ€ªç‰©åœ¨åœ°é¢ä¸Šæ–¹
            chaser.position.y = 2; 

            // --- ç¢°æ’æ£€æµ‹ (è¢«æŠ“) ---
            const dist = player.position.distanceTo(chaser.position);
            if (dist < 1.5) {
                gameOver("ä½ è¢«æŠ“ä½äº†ï¼ğŸ˜±");
            }

            // --- æ‰ä¸‹æ‚¬å´– ---
            if (player.position.y < -10) {
                gameOver("ä½ æ‰ä¸‹å»äº†...ğŸ« ");
            }

            renderer.render(scene, camera);
        }

        function gameOver(msg) {
            isGameOver = true;
            document.getElementById('status-text').innerText = msg;
            document.getElementById('overlay').style.display = 'flex';
        }

        animate();

        // é€‚é…å±å¹•å¤§å°
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
